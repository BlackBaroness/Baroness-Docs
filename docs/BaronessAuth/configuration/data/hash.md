---
sidebar_position: 2
title: Хеширование
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::tip Стоит взглянуть
У нас есть целая видео-лекция на эту тему, которая раскрывает суть гораздо нагляднее, чем текст.
Её можно посмотреть [здесь](../../main/lessons.md).
:::

## Что это?

Хеширование — постоянно применяемая в криптографии функция, позволяющая не хранить пароли в открытом виде. 
**Не путайте с шифрованием, это совершенно иная тема.**

Представьте это так: каждый пароль может создать уникальный хэш. 
Грубо говоря, пароль "abc" создаст хэш "12143234".
Любое изменение пароля полностью изменит хэш, что называется **лавинным эффектом**. 
При этом, одинаковый пароль **всегда** создаёт один и тот же хэш.

Можно ли обратить хэш обратно в пароль? Нет, это невозможно. 
BaronessAuth сверяет хэш введённого пароля и хэш в базе данных, чтобы подтвердить вход, он не знает настоящий пароль.

## Почему это так важно?

Кража базы данных без хеширования мгновенно бы обеспечила доступ к миллионам паролей.
Хеширование требует перебора миллиардов вариантов, чтобы найти тот самый пароль.

Но с BaronessAuth всё интереснее...

Если другие плагины используют всем известные алгоритмы, которые можно без труда перебрать, то с BaronessAuth вы собираете свой собственный.
Да, это значит, что для перебора и кражи пароля хакеру понадобится ещё и знать ваш алгоритм. И это не просто какой-нибудь MD5 - вы можете смешать воедино десятки разных алгоритмов!

## Подробнее о переборе

Представьте, перед вами хэш от какого-то пароля. Чтобы узнать, какой же это пароль был, придётся хэшировать тем же самым алгоритмом разные варианты до тех пор, пока хэш не совпадёт.

В таких случаях защищаться нужно 2-мя способами:
- Сложный пароль. Обязательно используйте проверку сложности BaronessAuth, лёгкие пароли есть в словарях для перебора.
- Сложный алгоритм. Запутайте хакера и оставьте его ни с чем, или, на крайний случай, заставьте перебирать несколько недель.

**На данный момент мы не можем предоставить хешрейт каждого алгоритма. Работаем над этим.**

## Настройка

```yaml title="data/hash.yml"
# Ваш алгоритм хеширования.
# Каждая строчка - алгоритм из списка ниже.
# Никаких ограничений по длине.
method:
  - 'name Tiger128'
  - 'Tiger128'
  - 'SALT'
  - 'Tiger128'

# Длина генерируемой динамической соли.
saltLength: 20
```

## Алгоритмы

### Особое

Различные особые алгоритмы, не являющиеся хешированием.

:::info Особое
<Tabs
defaultValue="name"
values={[
{label: "name", value: "name"},
{label: "SALT", value: "salt"},
{label: "NONE", value: "none"},
]}>

<TabItem value="name">
**Может быть вызвано только 1 раз.**

Задаёт имя готового хеша.

**Пример: `name MyHash`.**

Хеш строится по схеме `$имя$соль$хеш$`, поэтому рекомендуем указать этот параметр, иначе он будет помечен `empty`.

**Имеет смысл выставить бессмысленное название. Так, если хакер украдёт вашу базу данных, но у него не будет ваших настроек, он не сможет понять, как перебирать хеши.**

**Пример: используйте комбинацию Whirlpool_2+SALT+SHA512, назвав алгоритм SHA512. Хакер будет уверен, что вы используйте SHA512+SALT+SHA512, из-за чего никогда не найдёт ваш пароль.**
</TabItem>

<TabItem value="salt">
**Может быть вызвано только 1 раз.**

Создаёт соль с заданной длиной и высокой случайностью, после чего прибавляет к текущей строке.

**Настоятельно рекомендуем ВСЕГДА использовать соль.**
</TabItem>

<TabItem value="none">
Ничего.
</TabItem>
</Tabs>
:::

### С этой страницей проблемы, работаем над решением

```
### MD

Устаревшая семья, которая далеко не всегда отличается высокой скоростью. Ненадёжна.
Имеет множество коллизий.

Более старшие члены семьи надёжнее, но они всё равно неактуальны и не рекомендованы к использованию.

:::tip MD
<Tabs
defaultValue="MD2"
values={[
{label: "MD2", value: "MD2"},
{label: "MD4", value: "MD4"},
{label: "MD5", value: "MD5"},
]}>

<TabItem value="MD2">
Самый старый алгоритм семейства, официально признанный уязвимым в 2011 году.
MD1 не был открыто опубликован, поэтому семейство начинается с MD2.

`Длина: 32 символа.`
</TabItem>

<TabItem value="MD4">
Улучшенная версия MD5. Первые коллизии были найдены ещё в 1996 году.

`Длина: 32 символа.`
</TabItem>

<TabItem value="MD5">
Более надёжный вариант MD4, но коллизии, работающие в MD4, работают и в нём. 
После их нахождения, было решено переходить к полностью другим алгоритмам, таким как SHA-1.

`Длина: 32 символа.`
</TabItem>
</Tabs>
:::

### SHA + SHA2

Одно из известнейших семейств. Более старшие члены входят в стандарт госучреждений США. 

Члены после SHA1 считаются членами SHA2, но само семейство SHA2, фактически, является тем же самым SHA. Поэтому здесь они соединены.

:::info SHA + SHA2
<Tabs
defaultValue="SHA0"
values={[
{label: "SHA0", value: "SHA0"},
{label: "SHA1", value: "SHA1"},
{label: "SHA224", value: "SHA224"},
{label: "SHA256", value: "SHA256"},
{label: "SHA384", value: "SHA384"},
{label: "SHA512", value: "SHA512"},
]}>

<TabItem value="SHA0">
Самый первый алгоритм семьи, о котором практически нет информации. На данный момент известны только проблемы надёжности: атаки по коллизии, коих много.

`Длина: 40 символов.`
</TabItem>

<TabItem value="SHA1">
Один из самых быстрых алгоритмов, при этом достаточно надёжный.

**Надёжность определяется по отсутствию коллизий. Скорее всего, для вас важнее "тяжесть алгоритма" - выбирайте медленные.**

Имеет одну доказанную коллизию, которая требует огромнейших вычислительных мощностей.

`Длина: 40 символов.`
</TabItem>

<TabItem value="SHA224">
Алгоритм, входящий в стандарт госучреждений США. 
Редко используется и существует скорее для обратной совместимости, чем для постоянного использования.

Коллизии не найдены.

`Длина: 28 символов.`
</TabItem>

<TabItem value="SHA256">
Алгоритм, входящий в стандарт госучреждений США. 
Один из самых быстрых алгоритмов, при этом достаточно надёжный.

**Надёжность определяется по отсутствию коллизий. Скорее всего, для вас важнее "тяжесть алгоритма" - выбирайте медленные.**

Имеет одну доказанную коллизию, требующую значительных вычислительных мощностей.

`Длина: 32 символов.`
</TabItem>

<TabItem value="SHA384">
Алгоритм, входящий в стандарт госучреждений США. 
Редко используется и существует скорее для обратной совместимости, чем для постоянного использования.

Коллизии не найдены.

`Длина: 48 символов.`
</TabItem>

<TabItem value="SHA512">
Алгоритм, входящий в стандарт госучреждений США. 
Надёжнее, но медленнее "младших" братьев.

Имеет одну доказанную коллизию, требующую значительных вычислительных мощностей.

`Длина: 64 символов.`
</TabItem>
</Tabs>
:::

### SHA3

Так как SHA2 мало чем отличался от своего родителя, SHA3 решили менять на корню и писать новый алгоритм. 

Алгоритмы этого семейства более устойчивы к разным видам атак, но, как ни странно, они не очень популярны.

**Все описания SHA актуальны и для SHA3.**

:::tip SHA3
<Tabs
defaultValue="SHA3_224"
values={[
{label: "SHA3_224", value: "SHA3_224"},
{label: "SHA3_256", value: "SHA3_256"},
{label: "SHA3_384", value: "SHA3_384"},
{label: "SHA3_512", value: "SHA3_512"},
]}>
</Tabs>
:::

### Tiger

Семья, о которой вряд ли слышал простой пользователь, но которая хороша.
Вся семья отличается солидной устойчивостью **к коллизиям**, а члены по большей части отличаются только количеством бит.

:::info Tiger
<Tabs
defaultValue="Tiger"
values={[
{label: "Tiger", value: "Tiger"},
{label: "Tiger2", value: "Tiger2"},
{label: "Tiger128", value: "Tiger128"},
{label: "Tiger160", value: "Tiger160"},
]}>

<TabItem value="Tiger">

`Длина: 48 символов.`

</TabItem>

<TabItem value="Tiger2">
Новый алгоритм добавления битов, похожий на MD5 и SHA1.

`Длина: 48 символов.`
</TabItem>

<TabItem value="Tiger128">

`Длина: 32 символа.`

</TabItem>

<TabItem value="Tiger160">

`Длина: 40 символов символа.`

</TabItem>
</Tabs>
:::
```