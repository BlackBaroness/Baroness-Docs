---
sidebar_position: 2
title: Хеширование
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::tip Стоит взглянуть
У нас есть целая видео-лекция на эту тему, которая раскрывает суть гораздо нагляднее, чем текст.
Её можно посмотреть [здесь](../../main/lessons.md).
:::

## Что это?

Хеширование — постоянно применяемая в криптографии функция, позволяющая не хранить пароли в открытом виде. 
**Не путайте с шифрованием, это совершенно иная тема.**

Представьте это так: каждый пароль может создать уникальный хэш. 
Грубо говоря, пароль "abc" создаст хэш "12143234".
Любое изменение пароля полностью изменит хэш, что называется **лавинным эффектом**. 
При этом, одинаковый пароль **всегда** создаёт один и тот же хэш.

Можно ли обратить хэш обратно в пароль? Нет, это невозможно. 
BaronessAuth сверяет хэш введённого пароля и хэш в базе данных, чтобы подтвердить вход, он не знает настоящий пароль.

## Почему это так важно?

Кража базы данных без хеширования мгновенно бы обеспечила доступ к миллионам паролей.
Хеширование требует перебора миллиардов вариантов, чтобы найти тот самый пароль.

Но с BaronessAuth всё интереснее...

Если другие плагины используют всем известные алгоритмы, которые можно без труда перебрать, то с BaronessAuth вы собираете свой собственный.
Да, это значит, что для перебора и кражи пароля хакеру понадобится ещё и знать ваш алгоритм. И это не просто какой-нибудь MD5 - вы можете смешать воедино десятки разных алгоритмов!

## Подробнее о переборе

Представьте, перед вами хэш от какого-то пароля. Чтобы узнать, какой же это пароль был, придётся хэшировать тем же самым алгоритмом разные варианты до тех пор, пока хэш не совпадёт.

В таких случаях защищаться нужно 2-мя способами:
- Сложный пароль. Обязательно используйте проверку сложности BaronessAuth, лёгкие пароли есть в словарях для перебора.
- Сложный алгоритм. Запутайте хакера и оставьте его ни с чем, или, на крайний случай, заставьте перебирать несколько недель.

**На данный момент мы не можем предоставить хешрейт каждого алгоритма. Работаем над этим.**

## Алгоритмы

### Особое

Различные особые алгоритмы, не являющиеся хешированием.

:::info Особое
<Tabs
defaultValue="name"
values={[
{label: "name", value: "name"},
{label: "SALT", value: "salt"},
{label: "NONE", value: "none"},
]}>

<TabItem value="name">

**Может быть вызвано только 1 раз.**

Задаёт имя готового хеша.

**Пример: `name MyHash`.**

Хеш строится по схеме `$имя$соль$хеш$`, поэтому рекомендуем указать этот параметр, иначе он будет помечен `empty`.

**Имеет смысл выставить бессмысленное название. Так, если хакер украдёт вашу базу данных, но у него не будет ваших настроек, он не сможет понять, как перебирать хеши.**

**Пример: используйте комбинацию Whirlpool_2+SALT+SHA512, назвав алгоритм SHA512. Хакер будет уверен, что вы используйте SHA512+SALT+SHA512, из-за чего никогда не найдёт ваш пароль.**
</TabItem>

<TabItem value="salt">

**Может быть вызвано только 1 раз.**

Создаёт соль с заданной длиной и высокой случайностью, после чего прибавляет к текущей строке.

**Настоятельно рекомендуем ВСЕГДА использовать соль.**
</TabItem>

<TabItem value="none">
Ничего.
</TabItem>
</Tabs>
:::

### MD

Устаревшая семья, которая далеко не всегда отличается высокой скоростью. Ненадёжна.
Имеет множество коллизий.

Более старшие члены семьи надёжнее, но они всё равно неактуальны и не рекомендованы к использованию.

:::tip MD
<Tabs
defaultValue="MD2"
values={[
{label: "MD2", value: "MD2"},
{label: "MD4", value: "MD4"},
{label: "MD5", value: "MD5"},
]}>

<TabItem value="MD2">
Самый старый алгоритм семейства, официально признанный уязвимым в 2011 году.
MD1 не был открыто опубликован, поэтому семейство начинается с MD2.

`Длина: 32 символа.`
</TabItem>

<TabItem value="MD4">
Улучшенная версия MD5. Первые коллизии были найдены ещё в 1996 году.

`Длина: 32 символа.`
</TabItem>

<TabItem value="MD5">
Более надёжный вариант MD4, но коллизии, работающие в MD4, работают и в нём. 
После их нахождения, было решено переходить к полностью другим алгоритмам, таким как SHA-1.

`Длина: 32 символа.`
</TabItem>
</Tabs>
:::

### SHA/SHA2

Одно из известнейших семейств. Более старшие члены входят в стандарт госучреждений США. 

Члены после SHA1 считаются членами SHA2, но само семейство SHA2, фактически, является тем же самым SHA. Поэтому здесь они соединены.

:::tip SHA/SHA2
<Tabs
defaultValue="SHA0"
values={[
{label: "SHA0", value: "SHA0"},
{label: "SHA1", value: "SHA1"},
{label: "SHA224", value: "SHA224"},
{label: "SHA256", value: "SHA256"},
{label: "SHA384", value: "SHA384"},
{label: "SHA512", value: "SHA512"},
]}>

<TabItem value="SHA0">
Самый первый алгоритм семьи, о котором практически нет информации. На данный момент известны только проблемы надёжности: атаки по коллизии, коих много.

`Длина: 40 символов.`
</TabItem>

<TabItem value="SHA1">
Один из самых быстрых алгоритмов, при этом достаточно надёжный.

**Надёжность определяется по отсутствию коллизий. Скорее всего, для вас важнее "тяжесть алгоритма" - выбирайте медленные.**

Имеет одну доказанную коллизию, которая требует огромнейших вычислительных мощностей.

`Длина: 40 символов.`
</TabItem>

<TabItem value="SHA224">
Алгоритм, входящий в стандарт госучреждений США. 
Редко используется и существует скорее для обратной совместимости, чем для постоянного использования.

Коллизии не найдены.

`Длина: 28 символов.`
</TabItem>

<TabItem value="SHA256">
Алгоритм, входящий в стандарт госучреждений США. 
Один из самых быстрых алгоритмов, при этом достаточно надёжный.

**Надёжность определяется по отсутствию коллизий. Скорее всего, для вас важнее "тяжесть алгоритма" - выбирайте медленные.**

Имеет одну доказанную коллизию, требующую значительных вычислительных мощностей.

`Длина: 32 символов.`
</TabItem>

<TabItem value="SHA384">
Алгоритм, входящий в стандарт госучреждений США. 
Редко используется и существует скорее для обратной совместимости, чем для постоянного использования.

Коллизии не найдены.

`Длина: 48 символов.`
</TabItem>

<TabItem value="SHA512">
Алгоритм, входящий в стандарт госучреждений США. 
Надёжнее, но медленнее "младших" братьев.

Имеет одну доказанную коллизию, требующую значительных вычислительных мощностей.

`Длина: 64 символов.`
</TabItem>
</Tabs>
:::

### SHA3

Так как SHA2 мало чем отличался от своего родителя, SHA3 решили менять на корню и писать новый алгоритм. 

Алгоритмы этого семейства более устойчивы к разным видам атак, но, как ни странно, они не очень популярны.

:::tip SHA3
<Tabs
defaultValue="SHA3_224"
values={[
{label: "SHA3_224", value: "SHA3_224"},
{label: "SHA3_256", value: "SHA3_256"},
{label: "SHA3_384", value: "SHA3_384"},
{label: "SHA3_512", value: "SHA3_512"},
]}>

<TabItem value="SHA3_224">
Все описания SHA/SHA2 актуальны и для SHA3.
</TabItem>

<TabItem value="SHA3_256">
Все описания SHA/SHA2 актуальны и для SHA3.
</TabItem>

<TabItem value="SHA3_384">
Все описания SHA/SHA2 актуальны и для SHA3.
</TabItem>

<TabItem value="SHA3_512">
Все описания SHA/SHA2 актуальны и для SHA3.
</TabItem>

</Tabs>
:::


### Tiger

Семья, о которой вряд ли слышал простой пользователь, но которая хороша.
Вся семья отличается солидной устойчивостью **к коллизиям**, а члены по большей части отличаются только количеством бит.

:::tip Tiger
<Tabs
defaultValue="Tiger"
values={[
{label: "Tiger", value: "Tiger"},
{label: "Tiger2", value: "Tiger2"},
{label: "Tiger128", value: "Tiger128"},
{label: "Tiger160", value: "Tiger160"},
]}>

<TabItem value="Tiger">

`Длина: 48 символов.`

</TabItem>

<TabItem value="Tiger2">
Новый алгоритм добавления битов, похожий на MD5 и SHA1.

`Длина: 48 символов.`
</TabItem>

<TabItem value="Tiger128">

`Длина: 32 символа.`

</TabItem>

<TabItem value="Tiger160">

`Длина: 40 символов.`

</TabItem>
</Tabs>
:::


### BLAKE2B

Замечательное семейство, отличающееся приемлемой тяжестью и превосходной защитой (от коллизий). 

Используется в многих профессиональных проектах.

**Члены отличаются только количеством бит.**

:::tip BLAKE2B
<Tabs
defaultValue="BLAKE2B_160"
values={[
{label: "BLAKE2B_160", value: "BLAKE2B_160"},
{label: "BLAKE2B_256", value: "BLAKE2B_256"},
{label: "BLAKE2B_384", value: "BLAKE2B_384"},
{label: "BLAKE2B_512", value: "BLAKE2B_512"},
]}>

<TabItem value="BLAKE2B_160">

`Длина: 40 символов.`

</TabItem>

<TabItem value="BLAKE2B_256">

`Длина: 64 символа.`

</TabItem>

<TabItem value="BLAKE2B_384">

`Длина: 96 символов.`

</TabItem>

<TabItem value="BLAKE2B_512">

`Длина: 128 символов.`

</TabItem>

</Tabs>
:::


### Whirlpool

Семейство первоклассных алгоритмов, которые и быстрые, и надёжные. 

Более того - ни один член этого семейства до сих пор не поддался атакам по коллизиям. Это ли не повод использовать их?

:::tip BLAKE2B
<Tabs
defaultValue="Whirlpool_0"
values={[
{label: "Whirlpool_0", value: "Whirlpool_0"},
{label: "Whirlpool_1", value: "Whirlpool_1"},
{label: "Whirlpool_2", value: "Whirlpool_2"},
]}>

<TabItem value="Whirlpool_0">

Самый первый член семьи. Имел некоторые недоработки и был доработан в следующей версии.

`Длина: 128 символов.`

</TabItem>

<TabItem value="Whirlpool_1">

Улучшенная версия первого члена, которая вновь была доработана в следующей.

`Длина: 128 символов.`

</TabItem>

<TabItem value="Whirlpool_2">

Финальная версия прекрасного алгоритма.

`Длина: 128 символов.`

</TabItem>
</Tabs>
:::


### CRС

Обычно используется для подсчёта контрольной суммы файла (например, для сравнения, целый ли файл). **Является хеш-функцией, но не криптографической.**

Имеет очень много коллизий. **Есть смысл использовать только в специфичных задачах.**

Члены отличаются только по битам. Чем меньше бит, тем больше коллизий.


:::tip BLAKE2B
<Tabs
defaultValue="CRC8"
values={[
{label: "CRC8", value: "CRC8"},
{label: "CRC16", value: "CRC16"},
{label: "CRC24", value: "CRC24"},
{label: "CRC32", value: "CRC32"},
{label: "CRC64", value: "CRC64"},
]}>

<TabItem value="CRC8">

`Длина: 2 символа.`

</TabItem>

<TabItem value="CRC16">

`Длина: 5 символов.`

</TabItem>

<TabItem value="CRC24">

`Длина: 7 символов.`

</TabItem>

<TabItem value="CRC32">

`Длина: 10 символов.`

</TabItem>

<TabItem value="CRC64">

`Длина: 16 символов.`

</TabItem>
</Tabs>
:::


